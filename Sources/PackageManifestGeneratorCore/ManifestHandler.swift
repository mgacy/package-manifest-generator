//
//  ManifestHandler.swift
//  PackageManifestGenerator
//
//  Created by Mathew Gacy on 11/19/23.
//

import Foundation

/// A handler to decompose and assemble a generated package manifest.
struct ManifestHandler {
    /// The name of the `Package` instance declared in the package manifest.
    static let packageInstanceName = "package"

    /// The required package instance declaration.
    static var packageDeclaration: String {
        "\(packageInstanceName) = Package("
    }

    /// The separator placed between manifest sections.
    static let componentSeparator = "\n\n"

    /// The string indicating the beginning of the generated section of the manifest.
    static let generatedStart = """
    // Code between this separator and the next is autogenerated; do not edit
    // MARK: - Autogenerated
    """

    /// The string indicating the end of the generated section of the manifest.
    static let generatedEnd = """
    // Code below this separator may be edited
    // MARK: End Autogenerated -
    """

    /// The default code block placed after the generated section of the manifest.
    static var defaultSuffix: String {
        """
        \(packageInstanceName).products += \(Constants.generatedProductsName)
        \(packageInstanceName).targets += \(Constants.generatedTargetsName)
        """
    }

    /// Returns the manually-generated prefix and optional suffix from the given package manifest
    /// contents.
    ///
    /// - Parameter manifest: The contents of a package manifest.
    /// - Returns: A tuple that contains the `Package` instance declaration and optional statements
    /// modifying that instance.
    static func components(of manifest: String) throws -> (String, String?) {
        let startingComponents = manifest
            .components(separatedBy: generatedStart)
            .map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }

        guard let prefix = startingComponents.first else {
            throw "Missing package configuration"
        }
        guard prefix.contains(packageDeclaration) else {
            throw "Missing declaration of `Package` instance named `\(packageInstanceName)`"
        }

        var suffix: String?
        switch startingComponents.count {
        case 1:
            break

        case 2:
            let endingComponents = startingComponents[1]
                .components(separatedBy: generatedEnd)
                .map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }

            switch endingComponents.count {
            case 2:
                if endingComponents[1].isNotEmpty {
                    suffix = endingComponents[1]
                }

            default:
                throw "Invalid manifest"
            }

        default:
            throw "Invalid manifest"
        }

        return (prefix, suffix)
    }

    /// Returns the complete package manifest by assembling the given parts.
    ///
    /// - Parameters:
    ///   - prefix: The package declaration.
    ///   - generated: The generated product and target declarations.
    ///   - suffix: Statements modifying the package with the generated declarations.
    /// - Returns: The complete package manifest.
    static func assemble(prefix: String, generated: String, suffix: String? = nil) -> String {
        [
            prefix,
            generatedStart,
            generated,
            generatedEnd,
            suffix ?? defaultSuffix
        ].joined(separator: componentSeparator) + "\n"
    }
}
